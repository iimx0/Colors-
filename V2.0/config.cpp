#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <vector>
#include <sstream>
#include <algorithm>
#include <cctype>
#include <sys/stat.h>
#include <unistd.h>
#include <pwd.h>
#include "config.h"
#include "error.h"

std::string config_path;
std::map<std::string, UserConfig> config_cache;

std::string get_config_path() {
    const char* home = std::getenv("HOME");
    if (!home) {
        struct passwd* pw = getpwuid(getuid());
        if (!pw) {
            return "";
        }
        home = pw->pw_dir;
    }
    return std::string(home) + "/.prompt_config";
}

bool file_exists(const std::string& path) {
    struct stat buffer;
    return stat(path.c_str(), &buffer) == 0;
}

bool is_unicode_frame_char(const std::string& str, size_t pos) {
    if (pos + 2 >= str.length()) return false;
    
    unsigned char b1 = (unsigned char)str[pos];
    unsigned char b2 = (unsigned char)str[pos + 1];
    unsigned char b3 = (unsigned char)str[pos + 2];
    
    if (b1 == 0xE2 && b2 == 0x94) {
        return b3 == 0x80 || b3 == 0x8C || b3 == 0x94;
    }
    
    return false;
}

bool contains_only_allowed_chars(const std::string& str) {
    std::string allowed_ascii = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 _-[];\\n<>$#";
    
    for (size_t i = 0; i < str.length(); ) {
        if (is_unicode_frame_char(str, i)) {
            i += 3;
            continue;
        }
        
        char c = str[i];
        if (c >= 32 && c <= 126) {
            if (allowed_ascii.find(c) == std::string::npos) {
                return false;
            }
        } else {
            return false;
        }
        i++;
    }
    return true;
}

bool is_valid_tag_string(const std::string& tag) {
    if (tag.length() < 3) return false;
    if (tag[0] != '<' || tag[tag.length()-1] != '>') return false;
    
    for (size_t i = 1; i < tag.length() - 1; i++) {
        char c = tag[i];
        if (c == '<' || c == '>') return false;
        if (!std::isprint(c)) return false;
    }
    
    return true;
}

void create_default_config() {
    std::ofstream file(config_path);
    if (!file.is_open()) {
        return;
    }
    
    file << "# Prompt Configuration\n";
    file << "# Auto-generated by colorc\n\n";
    file << "default: ┌──[<user>]──[<path>]\\n└──<$>\n";
    file << "frame: ─;┌;└;[;];\n";
    file << "user: <user>\n";
    file << "path: <path>\n";
    file << "symbol$: <$>\n";
    file.close();
}

std::vector<std::string> split(const std::string& str, char delimiter) {
    std::vector<std::string> tokens;
    std::stringstream ss(str);
    std::string token;
    while (std::getline(ss, token, delimiter)) {
        if (!token.empty()) tokens.push_back(token);
    }
    return tokens;
}

bool validate_frame_symbols(const std::vector<std::string>& frame_symbols) {
    if (frame_symbols.size() != 5) return false;
    
    for (const auto& symbol : frame_symbols) {
        if (symbol.empty()) return false;
        if (!contains_only_allowed_chars(symbol)) return false;
    }
    
    return true;
}

bool validate_template_string(const std::string& template_str) {
    if (template_str.empty()) return false;
    
    if (!contains_only_allowed_chars(template_str)) return false;
    
    size_t escape_pos = 0;
    while ((escape_pos = template_str.find('\\', escape_pos)) != std::string::npos) {
        if (escape_pos + 1 >= template_str.length()) return false;
        if (template_str[escape_pos + 1] != 'n') return false;
        escape_pos += 2;
    }
    
    return true;
}

UserConfig parse_user_config(const std::vector<std::string>& lines) {
    UserConfig config;
    bool has_template = false;
    bool has_frame = false;
    bool has_user = false;
    bool has_path = false;
    bool has_symbol = false;
    
    for (const auto& line : lines) {
        if (line.find(": ") == std::string::npos) continue;
        
        size_t pos = line.find(": ");
        std::string key = line.substr(0, pos);
        std::string value = line.substr(pos + 2);
        
        if (key == "frame") {
            config.frame_symbols = split(value, ';');
            has_frame = true;
            
            if (!validate_frame_symbols(config.frame_symbols)) {
                config.frame_symbols.clear();
            }
        } else if (key == "user") {
            config.user_tag = value;
            has_user = true;
            
            if (!is_valid_tag_string(config.user_tag)) {
                config.user_tag.clear();
            }
        } else if (key == "path") {
            config.path_tag = value;
            has_path = true;
            
            if (!is_valid_tag_string(config.path_tag)) {
                config.path_tag.clear();
            }
        } else if (key == "symbol$") {
            config.symbol_tag = value;
            has_symbol = true;
            
            if (!is_valid_tag_string(config.symbol_tag)) {
                config.symbol_tag.clear();
            }
        } else {
            if (value.front() == '"' && value.back() == '"') {
                value = value.substr(1, value.length() - 2);
            }
            config.template_string = value;
            has_template = true;
            
            if (!validate_template_string(config.template_string)) {
                config.template_string.clear();
            }
        }
    }
    
    if (!has_template || !has_frame || !has_user || !has_path || !has_symbol) {
        config.template_string.clear();
    }
    
    return config;
}

void load_config() {
    config_path = get_config_path();
    if (config_path.empty()) {
        return;
    }
    
    if (!file_exists(config_path)) {
        create_default_config();
    }
    
    std::ifstream file(config_path);
    if (!file.is_open()) {
        return;
    }
    
    std::string line;
    std::string current_user;
    std::vector<std::string> current_lines;
    std::vector<std::string> all_users;
    
    while (std::getline(file, line)) {
        if (line.empty()) continue;
        
        if (line[0] == '#') continue;
        
        if (line.find(": ") != std::string::npos) {
            size_t pos = line.find(": ");
            std::string key = line.substr(0, pos);
            
            if (key != "frame" && key != "user" && key != "path" && key != "symbol$") {
                if (!current_user.empty()) {
                    if (std::find(all_users.begin(), all_users.end(), current_user) != all_users.end()) {
                        current_lines.clear();
                        current_user = "";
                        continue;
                    }
                    all_users.push_back(current_user);
                    config_cache[current_user] = parse_user_config(current_lines);
                    current_lines.clear();
                }
                current_user = key;
                current_lines.push_back(line);
            } else if (!current_user.empty()) {
                current_lines.push_back(line);
            }
        } else if (!current_user.empty()) {
            current_lines.push_back(line);
        }
    }
    
    if (!current_user.empty()) {
        if (std::find(all_users.begin(), all_users.end(), current_user) == all_users.end()) {
            config_cache[current_user] = parse_user_config(current_lines);
        }
    }
    
    file.close();
}

UserConfig get_user_config(const std::string& username) {
    if (config_cache.empty()) {
        load_config();
    }
    
    if (config_cache.find(username) != config_cache.end()) {
        return config_cache[username];
    }
    
    return UserConfig();
}

bool add_new_user(const std::string& username) {
    if (config_path.empty()) {
        config_path = get_config_path();
    }
    
    UserConfig default_config = get_user_config("default");
    if (default_config.template_string.empty()) {
        return false;
    }
    
    if (get_user_config(username).template_string.empty() == false) {
        return true;
    }
    
    std::ofstream file(config_path, std::ios::app);
    if (!file.is_open()) {
        return false;
    }
    
    file << "\n" << username << ": " << default_config.template_string << "\n";
    file << "frame: ";
    for (size_t i = 0; i < default_config.frame_symbols.size(); ++i) {
        file << default_config.frame_symbols[i];
        if (i < default_config.frame_symbols.size() - 1) file << ";";
    }
    file << "\n";
    file << "user: " << default_config.user_tag << "\n";
    file << "path: " << default_config.path_tag << "\n";
    file << "symbol$: " << default_config.symbol_tag << "\n";
    
    file.close();
    
    config_cache.clear();
    load_config();
    
    return true;
}